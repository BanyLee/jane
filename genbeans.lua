-- UTF-8 without BOM
local type = type
local string = string
local error = error
local pairs = pairs
local table = table
local concat = table.concat
local ipairs = ipairs
local print = print
local open = io.open

local jdk7 = true -- false for jdk6
local template_hint = "// This file is generated by genbeans tool. Do NOT edit it! @formatter:off\n"
local template_bean = template_hint .. [=[
package sas.bean;

import #(bean.imports);
#(bean.comment)
public final class #(bean.name) extends Bean<#(bean.name)> implements Comparable<#(bean.name)>
{
	private static final long serialVersionUID = #(bean.uid);
	public  static final int BEAN_TYPE = #(bean.type);
#{#	public  static final #(var.type) #(var.name)#(var.value);#(var.comment)
#}#
#(#	#(var.public) /*#(var.id2)*/ #(var.final)#(var.type) #(var.name);#(var.comment)
#)##<#
	public #(bean.name)()
	{
#(##(var.new)#)#	}

	public #(bean.name)(#(##(var.type_i) #(var.name), #)#)
	{
#(#		#(var.init);
#)#	}

#>#	@Override
	public void reset()
	{
#(#		#(var.reset);
#)#	}

	#(bean.param_warning)public void assign(#(bean.name) b)
	{#<#
		if(b == null) { reset(); return; }#>#
#(#		#(var.assign);
#)#	}
#(#
	public #(var.type) get#(var.name_u)()
	{
		return #(var.name);
	}
#(var.set)#)#
	@Override
	public int type()
	{
		return #(bean.type);
	}

	@Override
	public int initSize()
	{
		return #(bean.initsize);
	}

	@Override
	public int maxSize()
	{
		return #(bean.maxsize);
	}

	@Override
	public #(bean.name) create()
	{
		return new #(bean.name)();
	}

	@Override
	public OctetsStream marshal(OctetsStream s)
	{
#(#		#(var.marshal)
#)#		return s.marshal1((byte)0);
	}

	@Override
	public OctetsStream unmarshal(OctetsStream s) throws MarshalException
	{
		for(;;) { int i = s.unmarshalByte() & 0xff, t = i >> 6; switch(i & 0x3f)
		{
			case 0: return s;
#(#			#(var.unmarshal) break;
#)#			default: s.unmarshalSkipVar(t);
		}}
	}

	@Override
	public #(bean.name) clone()
	{
		return new #(bean.name)(#(##(var.name), #)#);
	}

	@Override
	public int hashCode()
	{
		int h = #(bean.type) * 0x9e3779b1;
#(#		h = h * 31 + 1 + #(var.hashcode);
#)#		return h;
	}

	@Override
	public boolean equals(Object o)
	{
		if(o == this) return true;
		if(!(o instanceof #(bean.name))) return false;#<#
		#(bean.name) b = (#(bean.name))o;#>#
#(#		if(#(var.equals)) return false;
#)#		return getClass() == o.getClass();
	}

	@Override
	public int compareTo(#(bean.name) b)
	{
		if(b == this) return 0;
		if(b == null) return 1;#<#
		int c;#>#
#(#		c = #(var.compareto); if(c != 0) return c;
#)#		return 0;
	}

	@Override
	public String toString()
	{
		StringBuilder s = new StringBuilder(16 + #(bean.initsize) * 2).append('{');#<#
#(#		#(var.tostring);
#)#		s.setLength(s.length() - 1);#>#
		return s.append('}').toString();
	}

	@Override
	public StringBuilder toJson(StringBuilder s)
	{
		if(s == null) s = new StringBuilder(1024);
		s.append('{');#<#
#(#		#(var.tojson);
#)#		s.setLength(s.length() - 1);#>#
		return s.append('}');
	}

	@Override
	public StringBuilder toLua(StringBuilder s)
	{
		if(s == null) s = new StringBuilder(1024);
		s.append('{');#<#
#(#		#(var.tolua);
#)#		s.setLength(s.length() - 1);#>#
		return s.append('}');
	}
}
]=]

local template_rpcbean = template_hint .. [=[
package sas.bean;

import sas.core.RPCBean;
#(bean.comment)
public final class #(bean.name) extends RPCBean<#(bean.arg), #(bean.res)>
{
	private static final long serialVersionUID = #(bean.uid);
	public #(bean.name)() {}
	public #(bean.name)(#(bean.arg) a) { arg = a; }
	@Override public int type() { return #(bean.type); }
	@Override public #(bean.name) create() { return new #(bean.name)(); }
	@Override public #(bean.arg) createArg() { return new #(bean.arg)(); }
	@Override public #(bean.res) createRes() { return new #(bean.res)(); }
}
]=]

local template_allbeans = template_hint .. [=[
package sas.bean;

import java.util.ArrayList;
import java.util.List;
import sas.core.Bean;
import sas.core.BeanCodec;#<#
import sas.core.BeanHandler;
import sas.core.IntMap;#>#

/** 全部beans的注册(自动生成的静态类) */
public final class AllBeans
{
	private AllBeans() {}

	/** 注册全部的beans到网络管理器. 必须在网络连接之前调用 */
	public static void register()
	{
		List<Bean<?>> r = new ArrayList<]=] .. (jdk7 and "" or "Bean<?>") .. [=[>(#(bean.count));
#(#		r.add(new #(bean.name)());
#)#		BeanCodec.instance().registerAllBeans(r);
	}
#[#
	public static IntMap<BeanHandler<?>> get#(hdl.name)Handlers()
	{
		IntMap<BeanHandler<?>> r = new IntMap<]=] .. (jdk7 and "" or "BeanHandler<?>") .. [=[>(#(hdl.count) * 4);
#(#		r.put(#(bean.type), new #(hdl.path).#(bean.name)Handler());
#)#		return r;
	}
#]#}
]=]

local template_bean_handler = [=[
package #(hdl.path);

import org.apache.mina.core.session.IoSession;
import sas.bean.#(bean.name);
import sas.core.BeanHandler;
import sas.core.BeanManager;
import sas.core.Log;

public final class #(bean.name)Handler extends BeanHandler<#(bean.name)>
{
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/

	@Override
	public void onProcess(BeanManager manager, IoSession session)
	{
		Log.log.debug("{}.onProcess: arg={}", getClass().getName(), arg);
	}
}
]=]

local template_rpc_handler = [=[
package #(hdl.path);

import org.apache.mina.core.session.IoSession;
import sas.bean.#(bean_arg.name);#<#
import sas.bean.#(bean_res.name);#>#
import sas.core.BeanManager;
import sas.core.Log;
import sas.core.RPCHandler;

public final class #(bean.name)Handler extends RPCHandler<#(bean_arg.name), #(bean_res.name)>
{
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/

	@Override
	public void onProcess(BeanManager manager, IoSession session)
	{
		Log.log.debug("{}.onProcess: {}", getClass().getName(), toString());
	}
}
]=]

local template_alltables = template_hint .. [=[
package sas.bean;

import #(tables.imports);

/** 全部的数据库表的注册和使用类(自动生成的静态类) */
public final class AllTables
{
	private AllTables() {}#<#
	private static final DBManager _dbm = DBManager.instance();#>#
	/**
	 * 注册全部的数据库表<p>
	 * 用于初始化和注册下面的全部静态成员(保持和AllBeans.register一致的用法), 并启动提交线程<br>
	 * 调用前要先初始化数据库管理器: DBManager.instance().startup(...)
	 */
	public static void register() {#<# _dbm.startCommitThread(); #>#}#<#
#>#
#(#	#(table.comment)public static final #(table.table)<#(table.key)#(table.comma)#(table.value)> #(table.name) = _dbm.openTable("#(table.name)", "#(table.lock)", #(table.cachesize)#(table.comma)#(table.keys), #(table.values));
#)#
	/**
	 * 以下内部类可以单独使用,避免初始化前面的表对象,主要用于获取表的键值类型
	 */
	public static final class Types
	{
		public static HashMap<String, Bean<?>> getKeyTypes()
		{
			HashMap<String, Bean<?>> r = new HashMap<]=] .. (jdk7 and "" or "String, Bean<?>") .. [=[>(#(tables.count) * 2);
#(#			r.put("#(table.name)", #(table.keyg));
#)#			return r;
		}

		public static HashMap<String, Bean<?>> getValueTypes()
		{
			HashMap<String, Bean<?>> r = new HashMap<]=] .. (jdk7 and "" or "String, Bean<?>") .. [=[>(#(tables.count) * 2);
#(#			r.put("#(table.name)", #(table.values));
#)#			return r;
		}
	}
}
]=]

local typedef = {}
local function merge(ta, tb)
	local r = {}
	for k, v in pairs(ta) do r[k] = v end
	for k, v in pairs(tb) do r[k] = v end
	return r
end
local function typename(var, t)
	local def = typedef[t]
	if not def then return t end
	if type(def) == "function" then
		local t = { id = 0, import = {} } def(t, 0) def = t
		for k in pairs(t.import) do var.import[k] = true end
	end
	if type(def) == "table" then return type(def.type) == "string" and def.type or def.type(var) end
	error("ERROR: unknown typename(" .. var .. ", " .. t .. ")")
end
local function subtypename(var, t)
	local def = typedef[t]
	if not def then return t end
	if type(def) == "function" then
		local t = { id = 0, import = {} } def(t, 0) def = t
		for k in pairs(t.import) do var.import[k] = true end
	end
	if type(def) == "table" then return type(def.type_o) == "string" and def.type_o or def.type_o(var) end
	error("ERROR: unknown subtypename(" .. var .. ", " .. t .. ")")
end
local function subtypename_new(var, t)
	if not var then return jdk7 and "" or ", " end
	return jdk7 and "" or subtypename(var, t)
end
local function subtypeid(t)
	local def = typedef[t]
	if not def then def = typedef.bean end
	if type(def) == "function" then local t = { id = 0, import = {} } def(t, 0) return t.subtypeid end
	if type(def) == "table" then return def.subtypeid end
	error("ERROR: unknown subtypeid(" .. t .. ")")
end
local function get_unmarshal_kv(var, kv, t)
	local s = (typedef[var[kv]] or typedef.bean).unmarshal_kv
	return type(s) == "string" and s or s(var, kv, t)
end
typedef.byte =
{
	import = {},
	name_u = function(var) return var.name:sub(1, 1):upper() .. var.name:sub(2) end,
	type = "byte", type_i = "byte", type_o = "Byte",
	subtypeid = 0,
	public = "public ",
	final = "",
	new = "",
	init = "this.#(var.name) = #(var.name)",
	reset = "#(var.name) = 0",
	assign = "this.#(var.name) = b.#(var.name)",
	set = [[

	public void set#(var.name_u)(#(var.type) #(var.name))
	{
		this.#(var.name) = #(var.name);
	}
]],
	marshal = "if(this.#(var.name) != 0) s.marshal1((byte)#(var.id)).marshal(this.#(var.name));",
	unmarshal = "case #(var.id): this.#(var.name) = (#(var.type))s.unmarshalInt(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "(" .. typename(var, var[kv]) .. ")s.unmarshalIntKV(" .. t .. ")" end end,
	hashcode = "this.#(var.name)",
	equals = "this.#(var.name) != b.#(var.name)",
	compareto = "this.#(var.name) - b.#(var.name)",
	tostring = "s.append(this.#(var.name)).append(',')",
	tojson = "s.append(\"\\\"#(var.name)\\\":\").append(this.#(var.name)).append(',')",
	tolua = "s.append(\"#(var.name)=\").append(this.#(var.name)).append(',')",
}
typedef.char  = merge(typedef.byte, { type = "char",  type_i = "char",  type_o = "Char"  })
typedef.short = merge(typedef.byte, { type = "short", type_i = "short", type_o = "Short" })
typedef.int = merge(typedef.byte,
{
	type = "int",
	type_i = "int",
	type_o = "Integer",
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalInt(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalIntKV(" .. t .. ")" end end,
})
typedef.long = merge(typedef.byte,
{
	type = "long",
	type_i = "long",
	type_o = "Long",
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalLong(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalLongKV(" .. t .. ")" end end,
	hashcode = "(int)this.#(var.name)",
	compareto = "Long.signum(this.#(var.name) - b.#(var.name))",
})
typedef.bool = merge(typedef.byte,
{
	type = "boolean", type_i = "boolean", type_o = "Boolean",
	reset = "#(var.name) = false",
	marshal = "if(this.#(var.name)) s.marshal1((byte)#(var.id)).marshal1((byte)1);",
	unmarshal = "case #(var.id): this.#(var.name) = (s.unmarshalInt(t) != 0);",
	unmarshal_kv = function(var, kv, t) if kv then return "(s.unmarshalIntKV(" .. t .. ") != 0)" end end,
	hashcode = "(this.#(var.name) ? 0xcafebabe : 0xdeadbeef)",
	compareto = "(this.#(var.name) == b.#(var.name) ? 0 : (this.#(var.name) ? 1 : -1))",
})
typedef.float = merge(typedef.byte,
{
	type = "float", type_i = "float", type_o = "Float",
	subtypeid = 4,
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal2(0x%04x).marshal(this.#(var.name));", 0xc000 + var.id * 0x100) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalFloat(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalFloatKV(" .. t .. ")" end end,
	hashcode = "Float.floatToRawIntBits(this.#(var.name))",
	compareto = "Float.compare(this.#(var.name), b.#(var.name))",
})
typedef.double = merge(typedef.byte,
{
	type = "double", type_i = "double", type_o = "Double",
	subtypeid = 5,
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal2(0x%04x).marshal(this.#(var.name));", 0xc001 + var.id * 0x100) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalDouble(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalDoubleKV(" .. t .. ")" end end,
	hashcode = "(int)Double.doubleToRawLongBits(this.#(var.name))",
	compareto = "Double.compare(this.#(var.name), b.#(var.name))",
})
typedef.string = merge(typedef.byte,
{
	import = { "sas.core.Util" },
	type = "String", type_i = "String", type_o = "String",
	subtypeid = 1,
	public = "private",
	new = "\t\t#(var.name) = \"\";\n",
	init = "this.#(var.name) = (#(var.name) != null ? #(var.name) : \"\")",
	reset = "#(var.name) = \"\"",
	assign = "this.#(var.name) = (b.#(var.name) != null ? b.#(var.name) : \"\")",
	set = [[

	public void set#(var.name_u)(#(var.type) #(var.name))
	{
		this.#(var.name) = (#(var.name) != null ? #(var.name) : "");
	}
]],
	marshal = function(var) return string.format("if(!this.#(var.name).isEmpty()) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", 0x40 + var.id) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalString(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalStringKV(" .. t .. ")" end end,
	hashcode = "this.#(var.name).hashCode()",
	equals = "!this.#(var.name).equals(b.#(var.name))",
	compareto = "this.#(var.name).compareTo(b.#(var.name))",
	tojson = "Util.toJStr(s.append(\"\\\"#(var.name)\\\":\"), this.#(var.name)).append(',')",
	tolua = "Util.toJStr(s.append(\"#(var.name)=\"), this.#(var.name)).append(',')",
})
typedef.octets = merge(typedef.string,
{
	import = { "sas.core.Octets" },
	type = "Octets", type_i = "Octets", type_o = "Octets",
	public = "public ",
	final = "final ",
	new = "\t\t#(var.name) = new Octets(#(var.cap));\n",
	init = "this.#(var.name) = new Octets(#(var.cap)); if(#(var.name) != null) this.#(var.name).replace(#(var.name))",
	reset = "#(var.name).clear()",
	assign = "if(b.#(var.name) != null) this.#(var.name).replace(b.#(var.name)); else this.#(var.name).clear()",
	set = "",
	marshal = function(var) return string.format("if(!this.#(var.name).empty()) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", 0x40 + var.id) end,
	unmarshal = "case #(var.id): s.unmarshal(this.#(var.name), t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalOctetsKV(" .. t .. ")" end end,
	tojson = "this.#(var.name).dumpJStr(s.append(\"\\\"#(var.name)\\\":\")).append(',')",
	tolua = "this.#(var.name).dumpJStr(s.append(\"#(var.name)=\")).append(',')",
})
typedef.vector = merge(typedef.octets,
{
	import = { "java.util.ArrayList", "java.util.Collection", "sas.core.Util" },
	type = function(var) return "ArrayList<" .. subtypename(var, var.k) .. ">" end,
	type_i = function(var) return "Collection<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new ArrayList<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new ArrayList<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).addAll(b.#(var.name))",
	marshal = function(var) return string.format([[if(!this.#(var.name).isEmpty())
		{
			s.marshal2(0x%04x).marshalUInt(this.#(var.name).size());
			for(%s v : this.#(var.name))
				s.marshal(v);
		}]], 0xc080 + var.id * 0x100 + subtypeid(var.k), subtypename(var, var.k)) end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t & 0xc0) != 0x80) { s.unmarshalSkipVarSub(t); break; }
				t &= 7;
				int n = s.unmarshalUInt();
				this.#(var.name).ensureCapacity(n < 0x10000 ? n : 0x10000);
				for(; n > 0; --n)
					this.#(var.name).add(%s);
			}]], get_unmarshal_kv(var, "k", "t")) end,
	compareto = "Util.compareTo(this.#(var.name), b.#(var.name))",
	tostring = "Util.append(s, this.#(var.name))",
	tojson = "Util.appendJson(s.append(\"\\\"#(var.name)\\\":\"), this.#(var.name))",
	tolua = "Util.appendLua(s.append(\"#(var.name)=\"), this.#(var.name))",
})
typedef.list = merge(typedef.vector,
{
	import = { "java.util.LinkedList", "java.util.Collection", "sas.core.Util" },
	type = function(var) return "LinkedList<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedList<" .. subtypename_new(var, var.k) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new LinkedList<" .. subtypename_new(var, var.k) .. ">(); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t & 0xc0) != 0x80) { s.unmarshalSkipVarSub(t); break; }
				t &= 7;
				for(int n = s.unmarshalUInt(); n > 0; --n)
					this.#(var.name).add(%s);
			}]], get_unmarshal_kv(var, "k", "t")) end,
})
typedef.deque = merge(typedef.list,
{
	import = { "java.util.ArrayDeque", "java.util.Collection", "sas.core.Util" },
	type = function(var) return "ArrayDeque<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new ArrayDeque<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new ArrayDeque<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.hashset = merge(typedef.list,
{
	import = { "java.util.HashSet", "java.util.Collection", "sas.core.Util" },
	type = function(var) return "HashSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new HashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new HashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.treeset = merge(typedef.list,
{
	import = { "java.util.TreeSet", "java.util.Collection", "sas.core.Util" },
	type = function(var) return "TreeSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new TreeSet<" .. subtypename_new(var, var.k) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new TreeSet<" .. subtypename_new(var, var.k) .. ">(); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.linkedhashset = merge(typedef.list,
{
	import = { "java.util.LinkedHashSet", "java.util.Collection", "sas.core.Util" },
	type = function(var) return "LinkedHashSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedHashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new LinkedHashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.hashmap = merge(typedef.list,
{
	import = { "java.util.HashMap", "java.util.Map.Entry", "java.util.Map", "sas.core.Util" },
	type = function(var) return "HashMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new HashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new HashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	marshal = function(var) return string.format([[if(!this.#(var.name).isEmpty())
		{
			s.marshal2(0x%04x).marshalUInt(this.#(var.name).size());
			for(Entry<%s, %s> e : this.#(var.name).entrySet())
				s.marshal(e.getKey()).marshal(e.getValue());
		}]], 0xc0c0 + var.id * 0x100 + subtypeid(var.k) * 8 + subtypeid(var.v), subtypename(var, var.k), subtypename(var, var.v)) end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t & 0xc0) != 0xc0) { s.unmarshalSkipVarSub(t); break; }
				int k = (t >> 3) & 7; t &= 7;
				for(int n = s.unmarshalUInt(); n > 0; --n)
					this.#(var.name).put(%s, %s);
			}]], get_unmarshal_kv(var, "k", "k"), get_unmarshal_kv(var, "v", "t")) end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.treemap = merge(typedef.hashmap,
{
	import = { "java.util.TreeMap", "java.util.Map", "sas.core.Util" },
	type = function(var) return "TreeMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new TreeMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new TreeMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.linkedhashmap = merge(typedef.hashmap,
{
	import = { "java.util.LinkedHashMap", "java.util.Map", "sas.core.Util" },
	type = function(var) return "LinkedHashMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedHashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new LinkedHashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.bean = merge(typedef.octets,
{
	import = {},
	type = function(var) return var.type end,
	type_i = function(var) return var.type end,
	type_o = function(var) return var.type end,
	subtypeid = 2,
	new = function(var) return "\t\t#(var.name) = new " .. var.type .. "();\n" end,
	init = function(var) return "this.#(var.name) = (#(var.name) != null ? #(var.name).clone() : new " .. var.type .. "())" end,
	reset = "#(var.name).reset()",
	assign = "this.#(var.name).assign(b.#(var.name))",
	marshal = function(var) return string.format([[{
			int n = s.size();
			this.#(var.name).marshal(s.marshal1((byte)0x%02x));
			if(s.size() - n < 3) s.resize(n);
		}]], 0x80 + var.id) end,
	unmarshal = "case #(var.id): s.unmarshalBean(this.#(var.name), t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalBeanKV(new " .. typename(var, var[kv]) .. "(), " .. t .. ")" end end,
	compareto = "this.#(var.name).compareTo(b.#(var.name))",
	tojson = "this.#(var.name).toJson(s.append(\"\\\"#(var.name)\\\":\")).append(',')",
	tolua = "this.#(var.name).toLua(s.append(\"#(var.name)=\")).append(',')",
})
typedef.boolean = typedef.bool
typedef.integer = typedef.int
typedef.binary = typedef.octets
typedef.bytes = typedef.octets
typedef.data = typedef.octets
typedef.array = typedef.vector
typedef.arraydeque = typedef.deque
typedef.arraylist = typedef.vector
typedef.linkedlist = typedef.list
typedef.set = typedef.hashset
typedef.linkedset = typedef.linkedhashset
typedef.map = typedef.hashmap
typedef.linkedmap = typedef.linkedhashmap

local function trim(s)
	return s:gsub("[%c ]+", "")
end
local function do_var(var)
	if var.id and (var.id < 1 or var.id > 62) then error("ERROR: id=" .. var.id .. " must be in [1, 62]") end
	if not var.id then var.id = 0 end
	var.import = {}
	var.id2 = string.format("%2d", var.id)
	var.name = trim(var.name)
	var.type = trim(var.type)
	if var.comment and #var.comment > 0 then var.comment = " // " .. var.comment:gsub("%c", " ") else var.comment = ""  end
	if type(var.value) == "string" then var.value = "\"" .. var.value .. "\"" end
	var.value = var.value and " = " .. var.value or ""
	local basetype
	basetype, var.k, var.v, var.cap = var.type:match "^%s*([%w_]+)%s*<?%s*([%w_]*)%s*,?%s*([%w_]*)%s*>?%s*%(?%s*([%w%._]*)%s*%)?%s*$"
	if not var.cap then var.cap = "" end
	local def = typedef[basetype]
	if not def and basetype == var.type then def = typedef.bean end
	if type(def) == "table" then
		for k, v in pairs(def) do
			if type(v) == "function" then v = v(var) end
			var[k] = v
		end
	else
		error("ERROR: unknown type: " .. var.type .. " => " .. basetype)
	end
end
local function code_conv(code, prefix, t)
	return code:gsub("#%(" .. prefix .. "%.([%w_]+)%)", function(name) return t[name] end)
end
local function gen_uid(s)
	local h = 0
	for i = 1, #s do
		h = h % 0x10000000000 * 4093 + 1 + s:byte(i)
	end
	return string.format("0xbeac%04x%08xL", math.floor(h / 0x100000000) % 0x10000, h % 0x100000000)
end

local name_code = {}
local type_bean = {}
local name_bean = {}
local handlers = {}
local hdl_types = {}
local bean_order = {}
local tables = { imports = { ["java.util.HashMap"] = true, ["sas.core.Bean"] = true } }
function handler(hdls)
	handlers = hdls
	for _, v in ipairs(hdls) do
		handlers[v.name] = v
	end
end
local function bean_common(bean)
	bean.name = trim(bean.name)
	if bean.name:find("[^%w_]") or typedef[bean.name] or bean.name == "AllBeans" or bean.name == "AllTables" then error("ERROR: invalid bean.name: " .. bean.name) end
	if name_code[bean.name] then error("ERROR: duplicated bean.name: " .. bean.name) end
	if type_bean[bean.type] then error("ERROR: duplicated bean.type: " .. bean.type) end
	if bean.type < 1 or bean.type > 0xffffffff then error("ERROR: invalid bean.type: " .. bean.type) end
	for name in (bean.handlers or ""):gmatch("([%w_]+)") do
		if not handlers[name] then error("ERROR: not defined handle: " .. name) end
		hdl_types[name] = hdl_types[name] or {}
		hdl_types[name][#hdl_types[name] + 1] = bean.type
	end
	type_bean[bean.type] = bean
	name_bean[bean.name] = bean
	bean.comment = bean.comment and #bean.comment > 0 and "\n/**\n * " .. bean.comment:gsub("\n", "<br>\n * ") .. "\n */" or ""
end
local function get_imports(import)
	local imports = {}
	for k in pairs(import) do
		imports[#imports + 1] = k
	end
	table.sort(imports)
	return concat(imports, ";\nimport ")
end
function bean(bean)
	bean_common(bean)

	bean.import = { ["sas.core.Bean"] = true, ["sas.core.MarshalException"] = true, ["sas.core.OctetsStream"] = true }
	local vartypes = { bean.name }
	for _, var in ipairs(bean) do
		do_var(var)
		if var.id > 0 then
			vartypes[#vartypes + 1] = var.type
			for _, v in ipairs(var.import) do
				bean.import[v] = true
			end
		end
	end
	bean.imports = get_imports(bean.import)
	bean.uid = gen_uid(concat(vartypes))

	local code = template_bean:gsub("#{#(.-)#}#", function(body)
		local subcode = {}
		for _, var in ipairs(bean) do
			if var.id == 0 then subcode[#subcode + 1] = code_conv(body, "var", var) end
		end
		return concat(subcode)
	end):gsub("#%(#(.-)#%)#", function(body)
		local subcode = {}
		for _, var in ipairs(bean) do
			if var.id > 0 then subcode[#subcode + 1] = code_conv(code_conv(body, "var", var), "var", var) end
		end
		local code = concat(subcode)
		return code:sub(-2, -1) ~= ", " and code or code:sub(1, -3)
	end)

	bean.param_warning = (#bean > 0 and "" or "/** @param b unused */\n\t")
	name_code[bean.name] = code_conv(code, "bean", bean):gsub(#bean > 0 and "#[<>]#" or "#<#(.-)#>#", ""):gsub("\r", "")
	bean_order[#bean_order + 1] = bean.name
end
function rpc(bean)
	bean_common(bean)
	bean.uid = gen_uid(name_bean[bean.arg].uid .. name_bean[bean.res].uid)
	name_code[bean.name] = code_conv(template_rpcbean, "bean", bean):gsub("\r", "")
	bean_order[#bean_order + 1] = bean.name
end
local key_conv = { int = "Integer", integer = "Integer", Integer = "Integer", long = "Long", Long = "Long", float = "Float", Float = "Float", double = "Double", Double = "Double",
					string = "String", String = "String", binary = "Octets", bytes = "Octets", data = "Octets", octets = "Octets", Octets = "Octets" }
function dbt(table)
	local key_type = key_conv[table.key]
	if key_type then
		if key_type == "Octets" then tables.imports["sas.core.Octets"] = true end
		table.table = "Table"
		table.key = key_type
		table.keys = not table.memory and key_type:find "%." and "new " .. key_type .. "()" or "null"
		table.keyg = table.keys
		table.comma = ", "
		tables.imports["sas.core.Table"] = true
	elseif table.key == "id" then
		table.table = "TableLong"
		table.key = ""
		table.keys = ""
		table.keyg = "null"
		table.comma = ""
		tables.imports["sas.core.TableLong"] = true
	else
		table.table = "Table"
		table.keys = not table.memory and "new #(table.key)()" or "null"
		table.keyg = table.keys
		table.comma = ", "
		tables.imports["sas.core.Table"] = true
	end
	table.values = table.memory and "null" or "new #(table.value)()"
	if table.comment and #table.comment > 0 then table.comment = "/**\n\t * " .. table.comment:gsub("\n", "<br>\n\t * ") .. "\n\t */\n\t" end
	tables[#tables + 1] = table
end

dofile "allbeans.lua"

local function checksave(fn, d, change_count, pattern, typename)
	local f = open(fn, "rb")
	if f then
		local s = f:read "*a"
		f:close()
		if change_count > 0 then
			d = s:gsub("\n\t/%*\\.-\n\t\\%*/", d:gmatch("\n\t/%*\\.-\n\t\\%*/"), change_count):gsub(pattern, typename, 1)
		end
		if s == d then d = nil else print("modify: " .. fn) end
	else
		print("create: " .. fn)
	end
	if d then
		f = open(fn, "wb")
		if not f then error("ERROR: can not create file: " .. fn) end
		f:write(d)
		f:close()
	end
end

local outpath = (arg[1] or "src"):gsub("\\", "/")
if outpath:sub(-1, -1) ~= "/" then outpath = outpath .. "/" end
for name, code in pairs(name_code) do
	checksave(outpath .. "sas/bean/" .. name .. ".java", code, 0)
end

checksave(outpath .. "sas/bean/AllBeans.java", (template_allbeans:gsub("#%[#(.-)#%]#", function(body)
	local subcode = {}
	for _, hdl in ipairs(handlers) do
		local types = hdl_types[hdl.name] or {}
		hdl.count = #types
		subcode[#subcode + 1] = code_conv(body:gsub("#%(#(.-)#%)#", function(body)
			local subcode2 = {}
			for _, type in ipairs(types) do
				local bean = type_bean[type]
				subcode2[#subcode2 + 1] = code_conv(body, "bean", bean)
				if not bean.arg then
					checksave(outpath .. hdl.path:gsub("%.", "/") .. "/" .. bean.name .. "Handler.java", code_conv(code_conv(template_bean_handler:gsub("#%(#(.-)#%)#", function(body)
						local subcode3 = {}
						for _, var in ipairs(bean) do
							subcode3[#subcode3 + 1] = code_conv(body, "var", var)
						end
						return concat(subcode3)
					end), "hdl", hdl), "bean", bean):gsub("\r", ""), 1, "(%s+class%s+" .. bean.name .. "Handler%s+extends%s+BeanHandler%s*<)[%w_%s]+>", "%1" .. bean.name .. ">")
				else
					local bean_sub
					local bean_arg, bean_res = name_bean[bean.arg], name_bean[bean.res]
					checksave(outpath .. hdl.path:gsub("%.", "/") .. "/" .. bean.name .. "Handler.java", code_conv(code_conv(code_conv(code_conv(template_rpc_handler:gsub("#%(#(.-)#%)#", function(body)
						bean_sub = bean_sub and bean_res or bean_arg
						local subcode3 = {}
						for _, var in ipairs(bean_sub) do
							subcode3[#subcode3 + 1] = code_conv(body, "var", var)
						end
						return concat(subcode3)
					end), "hdl", hdl), "bean", bean), "bean_arg", bean_arg), "bean_res", bean_res):gsub(bean_arg ~= bean_res and "#[<>]#" or "#%<#(.-)#%>#", ""):
						gsub("\r", ""), 2, "(%s+class%s+" .. bean.name .. "Handler%s+extends%s+RPCHandler%s*<)[%w_%s]+,[%w_%s]+>", "%1" .. bean_arg.name .. ", " .. bean_res.name .. ">")
				end
			end
			return concat(subcode2)
		end), "hdl", hdl)
	end
	return concat(subcode)
end):gsub("#%(#(.-)#%)#", function(body)
	local subcode = {}
	for _, beanname in ipairs(bean_order) do
		local bean = name_bean[beanname]
		subcode[#subcode + 1] = code_conv(body, "bean", bean)
	end
	return concat(subcode)
end)):gsub(#handlers > 0 and "#[<>]#" or "#%<#(.-)#%>#", ""):gsub("#%(bean.count%)", #bean_order):gsub("\r", ""), 0)

tables.count = #tables
if tables.count > 0 then tables.imports["sas.core.DBManager"] = true end
tables.imports = get_imports(tables.imports)
checksave(outpath .. "sas/bean/AllTables.java", (code_conv(template_alltables:gsub("#%(#(.-)#%)#", function(body)
	local subcode = {}
	for _, table in ipairs(tables) do
		subcode[#subcode + 1] = code_conv(code_conv(body, "table", table), "table", table)
	end
	return concat(subcode)
end), "tables", tables):gsub(#tables > 0 and "#[<>]#" or "#<#(.-)#>#", ""):gsub("\r", "")), 0)

print "completed!"
