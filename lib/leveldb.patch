 .gitignore            |   3 +
 build_detect_platform |  14 +-
 port/port_posix.h     |  58 ++++++++-
 util/env_posix.cc     |   4 +
 util/env_windows.cc   | 354 ++++++++++++++++++++++++++++++++++++++++++++++++++
 util/jni.cc           | 130 ++++++++++++++++++
 6 files changed, 561 insertions(+), 2 deletions(-)

diff --git a/.gitignore b/.gitignore
index 0630251..0dba0c5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,6 +4,9 @@ build_config.mk
 *.dylib*
 *.so
 *.so.*
+*.dll
+*.dll.*
 *_test
 db_bench
 leveldbutil
+/tmp/
diff --git a/build_detect_platform b/build_detect_platform
index 6e59c6f..11baee5 100755
--- a/build_detect_platform
+++ b/build_detect_platform
@@ -82,7 +82,8 @@ case "$TARGET_OS" in
         ;;
     Linux)
         PLATFORM=OS_LINUX
-        COMMON_FLAGS="$MEMCMP_FLAG -pthread -DOS_LINUX"
+#       COMMON_FLAGS="$MEMCMP_FLAG -pthread -DOS_LINUX"
+        COMMON_FLAGS="$MEMCMP_FLAG -pthread -DOS_LINUX -DENABLE_JNI -I/usr/java/default/include -I/usr/java/default/include/linux"
         PLATFORM_LDFLAGS="-pthread"
         PORT_FILE=port/port_posix.cc
         ;;
@@ -141,6 +142,17 @@ case "$TARGET_OS" in
         PLATFORM_SHARED_CFLAGS=
         PLATFORM_SHARED_VERSIONED=
         ;;
+    MINGW*)
+        PLATFORM=OS_LINUX
+#       COMMON_FLAGS="$MEMCMP_FLAG -pthread -DOS_LINUX -DOS_MINGW"
+#       PLATFORM_LDFLAGS="-lpthread -static -s"
+        COMMON_FLAGS="$MEMCMP_FLAG -pthread -DOS_LINUX -DOS_MINGW -DENABLE_JNI -I\"${JAVA_HOME}/include\" -I\"${JAVA_HOME}/include/win64\" -I\"${JAVA_HOME}/include/win32\""
+        PLATFORM_LDFLAGS="-lpthread -static -s -Wl,--kill-at"
+        PORT_FILE=port/port_posix.cc
+        PLATFORM_SHARED_EXT="dll"
+        PLATFORM_SHARED_CFLAGS=
+        PLATFORM_SHARED_VERSIONED=
+        ;;
     *)
         echo "Unknown platform!" >&2
         exit 1
diff --git a/port/port_posix.h b/port/port_posix.h
index f2b89bf..5f2cac5 100644
--- a/port/port_posix.h
+++ b/port/port_posix.h
@@ -37,6 +37,62 @@
   // See http://code.google.com/p/android/issues/detail?id=39824
   #include <endian.h>
   #define PLATFORM_IS_LITTLE_ENDIAN  (_BYTE_ORDER == _LITTLE_ENDIAN)
+#elif defined(OS_MINGW)
+  #define PLATFORM_IS_LITTLE_ENDIAN true
+  #include <stdarg.h>
+  #include <string.h>
+  #include <stdio.h>
+  inline const char* cvt_fmt(const char* buf)
+  {
+    static char* s_buf = new char[65536]; // big enough
+    char* d = s_buf;
+    for(const char* p = buf;;)
+    {
+      const char* q = strstr(p, "ll");
+      if(!q)
+      {
+        if(p == buf) return buf;
+        strcpy(d, p);
+        return s_buf;
+      }
+      if(q[2] == 'd' || q[2] == 'u')
+      {
+        int n = q - p;
+        memcpy(d, p, n); d += n;
+        memcpy(d, "I64", 3); d += 3;
+      }
+      else
+      {
+        int n = q - p + 2;
+        memcpy(d, p, n); d += n;
+      }
+      p = q + 2;
+    }
+  }
+  inline int printf_fix(const char* fmt, ...)
+  {
+    va_list vl;
+    va_start(vl, fmt);
+    vprintf(cvt_fmt(fmt), vl);
+    va_end(vl);
+  }
+  inline int fprintf_fix(FILE* fp, const char* fmt, ...)
+  {
+    va_list vl;
+    va_start(vl, fmt);
+    vfprintf(fp, cvt_fmt(fmt), vl);
+    va_end(vl);
+  }
+  inline int snprintf_fix(char* buf, size_t buflen, const char* fmt, ...)
+  {
+    va_list vl;
+    va_start(vl, fmt);
+    _vsnprintf(buf, buflen, cvt_fmt(fmt), vl);
+    va_end(vl);
+  }
+  #define printf printf_fix
+  #define fprintf fprintf_fix
+  #define snprintf snprintf_fix
 #else
   #include <endian.h>
 #endif
@@ -55,7 +111,7 @@
 
 #if defined(OS_MACOSX) || defined(OS_SOLARIS) || defined(OS_FREEBSD) ||\
     defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_DRAGONFLYBSD) ||\
-    defined(OS_ANDROID) || defined(OS_HPUX)
+    defined(OS_ANDROID) || defined(OS_HPUX) || defined(OS_MINGW)
 // Use fread/fwrite/fflush on platforms without _unlocked variants
 #define fread_unlocked fread
 #define fwrite_unlocked fwrite
diff --git a/util/env_posix.cc b/util/env_posix.cc
index e1cbebd..d706df7 100644
--- a/util/env_posix.cc
+++ b/util/env_posix.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file. See the AUTHORS file for names of contributors.
 
+#ifndef OS_MINGW
+
 #include <deque>
 #include <set>
 #include <dirent.h>
@@ -605,3 +607,5 @@ Env* Env::Default() {
 }
 
 }  // namespace leveldb
+
+#endif
diff --git a/util/env_windows.cc b/util/env_windows.cc
new file mode 100644
index 0000000..db9ba47
--- /dev/null
+++ b/util/env_windows.cc
@@ -0,0 +1,354 @@
+#ifdef WIN32
+
+#define _WIN32_WINNT 0x500
+#include <windows.h>
+#undef DeleteFile
+#undef min
+#include "leveldb/env.h"
+#include "port/port.h"
+
+namespace leveldb {
+namespace {
+
+struct ThreadParam {
+	void (*function)(void* arg);
+	void* arg;
+	ThreadParam(void (*function)(void* arg), void* arg) : function(function), arg(arg) {}
+};
+
+DWORD WINAPI ThreadProc(LPVOID lpParameter) {
+	ThreadParam* param = static_cast<ThreadParam*>(lpParameter);
+	void (*function)(void* arg) = param->function;
+	void* arg = param->arg;
+	delete param;
+	function(arg);
+	return 0;
+}
+
+class WindowsSequentialFile : public SequentialFile {
+	std::string fname_;
+	HANDLE file_;
+
+public:
+	WindowsSequentialFile(const std::string& fname, HANDLE file) : fname_(fname), file_(file) {}
+	virtual ~WindowsSequentialFile() { CloseHandle(file_); }
+
+	virtual Status Read(size_t n, Slice* result, char* scratch) {
+		DWORD bytesRead = 0;
+		BOOL success = ReadFile(file_, scratch, n, &bytesRead, 0);
+		*result = Slice(scratch, bytesRead);
+		return success ? Status::OK() : Status::IOError(fname_);
+	}
+
+	virtual Status Skip(uint64_t n) {
+		LARGE_INTEGER li;
+		li.QuadPart = n;
+		return SetFilePointerEx(file_, li, 0, FILE_CURRENT) ? Status::OK() : Status::IOError(fname_);
+	}
+};
+
+// A file abstraction for randomly reading the contents of a file.
+class WindowsRandomAccessFile : public RandomAccessFile {
+	std::string fname_;
+	HANDLE file_;
+
+public:
+	WindowsRandomAccessFile(const std::string& fname, HANDLE file) : fname_(fname), file_(file) {}
+	virtual ~WindowsRandomAccessFile() { CloseHandle(file_); }
+
+	virtual Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
+		OVERLAPPED overlapped = {0};
+		overlapped.Offset = static_cast<DWORD>(offset);
+		overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);
+		DWORD bytesRead = 0;
+		BOOL success = ReadFile(file_, scratch, n, &bytesRead, &overlapped);
+		*result = Slice(scratch, bytesRead);
+		return success ? Status::OK() : Status::IOError(fname_);
+	}
+};
+
+class WindowsWritableFile : public WritableFile {
+	static const size_t kBufferSize = 65536;
+	std::string fname_;
+	HANDLE file_;
+	size_t pos_;
+	BYTE buffer_[kBufferSize];
+
+public:
+	WindowsWritableFile(const std::string& fname, HANDLE file) : fname_(fname), file_(file), pos_(0) {}
+	virtual ~WindowsWritableFile() { CloseHandle(file_); }
+
+	virtual Status Append(const Slice& data) {
+		size_t totalBytesWritten = 0;
+		while(totalBytesWritten < data.size()) {
+			if(pos_ == kBufferSize) Flush();
+			size_t size = std::min(kBufferSize - pos_, data.size() - totalBytesWritten);
+			memcpy(buffer_ + pos_, data.data() + totalBytesWritten, size);
+			pos_ += size;
+			totalBytesWritten += size;
+		}
+		return Status::OK();
+	}
+
+	virtual Status Close() {
+		Status status = Flush();
+		CloseHandle(file_);
+		file_ = INVALID_HANDLE_VALUE;
+		return status;
+	}
+
+	virtual Status Flush() {
+		size_t pos = 0;
+		while(pos < pos_) {
+			DWORD bytesWritten = 0;
+			if(!WriteFile(file_, &buffer_[pos], pos_ - pos, &bytesWritten, 0))
+				return Status::IOError(fname_);
+			pos += bytesWritten;
+		}
+		pos_ = 0;
+		return Status::OK();
+	}
+
+	virtual Status Sync() {
+		Status status = Flush();
+		if(!status.ok()) return status;
+		return FlushFileBuffers(file_) ? Status::OK() : Status::IOError(fname_);
+	}
+};
+
+class WindowsFileLock : public FileLock {
+	std::string fname_;
+	HANDLE file_;
+
+public:
+	WindowsFileLock(const std::string& fname, HANDLE file) : fname_(fname), file_(file) {}
+	virtual ~WindowsFileLock() { Close(); }
+	const std::string& GetFileName() { return fname_; }
+
+	bool Close() {
+		bool success = (file_ == INVALID_HANDLE_VALUE || CloseHandle(file_));
+		file_ = INVALID_HANDLE_VALUE;
+		return success;
+	}
+};
+
+class WindowsLogger : public Logger {
+	WritableFile* log_;
+
+public:
+	WindowsLogger(WritableFile* log) : log_(log) {}
+	virtual ~WindowsLogger() { delete log_; }
+
+	// Write an entry to the log file with the specified format.
+	virtual void Logv(const char* format, va_list ap) {
+		const size_t kBufSize = 4096;
+		char buffer[kBufSize];
+		int written = _vsnprintf(buffer, kBufSize, cvt_fmt(format), ap);
+		log_->Append(Slice(buffer, written >= 0 ? written : kBufSize));
+		log_->Append(Slice("\n", 1));
+	}
+};
+
+}
+
+class WindowsEnv : public Env {
+	LARGE_INTEGER freq_;
+
+public:
+	WindowsEnv() { QueryPerformanceFrequency(&freq_); }
+
+	// Create a brand new sequentially-readable file with the specified name.
+	// On success, stores a pointer to the new file in *result and returns OK.
+	// On failure stores 0 in *result and returns non-OK.  If the file does
+	// not exist, returns a non-OK status.
+	//
+	// The returned file will only be accessed by one thread at a time.
+	virtual Status NewSequentialFile(const std::string& fname, SequentialFile** result) {
+		*result = 0;
+		HANDLE file = CreateFileA(fname.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+			0, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);
+		if(file == INVALID_HANDLE_VALUE) return Status::IOError(fname);
+		*result = new WindowsSequentialFile(fname, file);
+		return Status::OK();
+	}
+
+	// Create a brand new random access read-only file with the
+	// specified name.  On success, stores a pointer to the new file in
+	// *result and returns OK.  On failure stores 0 in *result and
+	// returns non-OK.  If the file does not exist, returns a non-OK
+	// status.
+	//
+	// The returned file may be concurrently accessed by multiple threads.
+	virtual Status NewRandomAccessFile(const std::string& fname, RandomAccessFile** result) {
+		*result = 0;
+		HANDLE file = CreateFileA(fname.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+			0, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, 0);
+		if(file == INVALID_HANDLE_VALUE) return Status::IOError(fname);
+		*result = new WindowsRandomAccessFile(fname, file);
+		return Status::OK();
+	}
+
+	// Create an object that writes to a new file with the specified
+	// name.  Deletes any existing file with the same name and creates a
+	// new file.  On success, stores a pointer to the new file in
+	// *result and returns OK.  On failure stores 0 in *result and
+	// returns non-OK.
+	//
+	// The returned file will only be accessed by one thread at a time.
+	virtual Status NewWritableFile(const std::string& fname, WritableFile** result) {
+		*result = 0;
+		HANDLE file = CreateFileA(fname.c_str(), GENERIC_WRITE, FILE_SHARE_READ, 0, CREATE_ALWAYS, 0, 0);
+		if(file == INVALID_HANDLE_VALUE) return Status::IOError(fname);
+		*result = new WindowsWritableFile(fname, file);
+		return Status::OK();
+	}
+
+	virtual bool FileExists(const std::string& fname) {
+		DWORD attr = GetFileAttributesA(fname.c_str());
+		return attr != INVALID_FILE_ATTRIBUTES && !(attr & FILE_ATTRIBUTE_DIRECTORY);
+	}
+
+	// Store in *result the names of the children of the specified directory.
+	// The names are relative to "dir".
+	// Original contents of *results are dropped.
+	virtual Status GetChildren(const std::string& dir, std::vector<std::string>* result) {
+		result->clear();
+		std::string dirWildcard(dir);
+		dirWildcard.append("\\*");
+		WIN32_FIND_DATAA fd = {0};
+		HANDLE h = FindFirstFileA(dirWildcard.c_str(), &fd);
+		if(h == INVALID_HANDLE_VALUE) return Status::IOError(dir);
+		do {
+			if(!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+				result->push_back(fd.cFileName);
+		}
+		while(FindNextFileA(h, &fd));
+		FindClose(h);
+		return Status::OK();
+	}
+
+	virtual Status DeleteFile(const std::string& fname) {
+		return DeleteFileA(fname.c_str()) ? Status::OK() : Status::IOError(fname);
+	}
+
+	virtual Status CreateDir(const std::string& dirname) {
+		return CreateDirectoryA(dirname.c_str(), 0) ? Status::OK() : Status::IOError(dirname);
+	}
+
+	virtual Status DeleteDir(const std::string& dirname) {
+		std::string dirname2(dirname);
+		dirname2.push_back('\0');
+		SHFILEOPSTRUCTA fileop = {0};
+		fileop.wFunc = FO_DELETE;
+		fileop.pFrom = dirname2.c_str();
+		fileop.fFlags = 0; // FOF_NO_UI;
+		int nResult = SHFileOperationA(&fileop);
+		return !nResult && !fileop.fAnyOperationsAborted ? Status::OK() : Status::IOError(dirname);
+	}
+
+	virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {
+		*file_size = 0;
+		WIN32_FILE_ATTRIBUTE_DATA fad;
+		if(!GetFileAttributesExA(fname.c_str(), GetFileExInfoStandard, &fad))
+			return Status::IOError(fname);
+		*file_size = (static_cast<uint64_t>(fad.nFileSizeHigh) << 32) + fad.nFileSizeLow;
+		return Status::OK();
+	}
+
+	virtual Status RenameFile(const std::string& src, const std::string& target) {
+		return MoveFileExA(src.c_str(), target.c_str(), MOVEFILE_REPLACE_EXISTING) ?
+			Status::OK() : Status::IOError(src, target);
+	}
+
+	// Lock the specified file.  Used to prevent concurrent access to
+	// the same db by multiple processes.  On failure, stores 0 in
+	// *lock and returns non-OK.
+	//
+	// On success, stores a pointer to the object that represents the
+	// acquired lock in *lock and returns OK.  The caller should call
+	// UnlockFile(*lock) to release the lock.  If the process exits,
+	// the lock will be automatically released.
+	//
+	// If somebody else already holds the lock, finishes immediately
+	// with a failure.  I.e., this call does not wait for existing locks
+	// to go away.
+	//
+	// May create the named file if it does not already exist.
+	virtual Status LockFile(const std::string& fname, FileLock** lock) {
+		*lock = 0;
+		HANDLE file = CreateFileA(fname.c_str(), GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_ALWAYS, 0, 0);
+		if(file == INVALID_HANDLE_VALUE) return Status::IOError(fname);
+		*lock = new WindowsFileLock(fname, file);
+		return Status::OK();
+	}
+
+	// Release the lock acquired by a previous successful call to LockFile.
+	// REQUIRES: lock was returned by a successful LockFile() call
+	// REQUIRES: lock has not already been unlocked.
+	virtual Status UnlockFile(FileLock* lock) {
+		WindowsFileLock* my_lock = dynamic_cast<WindowsFileLock*>(lock);
+		Status result;
+		if(my_lock && !my_lock->Close())
+			result = Status::IOError(my_lock->GetFileName(), "Could not close lock file.");
+		delete my_lock;
+		return result;
+	}
+
+	// Arrange to run "(*function)(arg)" once in a background thread.
+	//
+	// "function" may run in an unspecified thread.  Multiple functions
+	// added to the same Env may run concurrently in different threads.
+	// I.e., the caller may not assume that background work items are
+	// serialized.
+	virtual void Schedule(void (*function)(void* arg), void* arg) {
+		QueueUserWorkItem(ThreadProc, new ThreadParam(function, arg), WT_EXECUTEDEFAULT);
+	}
+
+	// Start a new thread, invoking "function(arg)" within the new thread.
+	// When "function(arg)" returns, the thread will be destroyed.
+	virtual void StartThread(void (*function)(void* arg), void* arg) {
+		CreateThread(0, 0, ThreadProc, new ThreadParam(function, arg), 0, 0);
+	}
+
+	// *path is set to a temporary directory that can be used for testing. It may
+	// or many not have just been created. The directory may or may not differ
+	// between runs of the same process, but subsequent calls will return the
+	// same directory.
+	virtual Status GetTestDirectory(std::string* path) {
+		char tempPath[MAX_PATH];
+		GetTempPathA(MAX_PATH, &tempPath[0]);
+		*path = tempPath;
+		return Status::OK();
+	}
+
+	// Create and return a log file for storing informational messages.
+	virtual Status NewLogger(const std::string& fname, Logger** result) {
+		*result = 0;
+		WritableFile* logfile;
+		Status status = NewWritableFile(fname, &logfile);
+		if(status.ok()) *result = new WindowsLogger(logfile);
+		return status;
+	}
+
+	// Returns the number of micro-seconds since some fixed point in time. Only
+	// useful for computing deltas of time.
+	virtual uint64_t NowMicros() {
+		LARGE_INTEGER count;
+		QueryPerformanceCounter(&count);
+		return count.QuadPart * 1000000LL / freq_.QuadPart;
+	}
+
+	virtual void SleepForMicroseconds(int micros) {
+		// round up to the next millisecond
+		Sleep((micros + 999) / 1000);
+	}
+};
+
+Env* Env::Default() {
+	static WindowsEnv g_env;
+	return &g_env;
+}
+
+}
+
+#endif
diff --git a/util/jni.cc b/util/jni.cc
new file mode 100644
index 0000000..b7f10db
--- /dev/null
+++ b/util/jni.cc
@@ -0,0 +1,130 @@
+#ifdef ENABLE_JNI
+
+#include <jni.h>
+#include "leveldb/db.h"
+#include "leveldb/options.h"
+#include "leveldb/cache.h"
+#include "leveldb/write_batch.h"
+
+using namespace leveldb;
+
+static ReadOptions g_ro;
+static WriteOptions g_wo;
+static WriteBatch g_wb; // optimized for single thread writing
+
+// public native static long leveldb_open(String path, int write_bufsize, int cache_size);
+extern "C" JNIEXPORT jlong JNICALL Java_jane_core_StorageLevelDB_leveldb_1open
+	(JNIEnv* jenv, jclass jcls, jstring path, jint write_bufsize, jint cache_size)
+{
+	if(!path) return 0;
+	Options opt;
+	opt.create_if_missing = true;
+	opt.write_buffer_size = (write_bufsize > 0x100000 ? write_bufsize : 0x100000);
+	opt.block_cache = NewLRUCache(cache_size > 0x100000 ? cache_size : 0x100000);
+	opt.compression = kNoCompression;
+	g_ro.fill_cache = false;
+	g_wo.sync = true;
+	const char* pathptr = jenv->GetStringUTFChars(path, 0);
+	DB* db = 0;
+	Status s = DB::Open(opt, pathptr, &db);
+	jenv->ReleaseStringUTFChars(path, pathptr);
+	return s.ok() ? (jlong)db : 0;
+}
+
+// public native static void leveldb_close(long handle);
+extern "C" JNIEXPORT void JNICALL Java_jane_core_StorageLevelDB_leveldb_1close
+	(JNIEnv* jenv, jclass jcls, jlong handle)
+{
+	delete (DB*)handle;
+}
+
+// public native static byte[] leveldb_get(long handle, byte[] key, int keylen);
+extern "C" JNIEXPORT jbyteArray JNICALL Java_jane_core_StorageLevelDB_leveldb_1get
+	(JNIEnv* jenv, jclass jcls, jlong handle, jbyteArray key, jint keylen)
+{
+	DB* db = (DB*)handle;
+	if(!db || !key) return 0;
+	jsize m = jenv->GetArrayLength(key); if(keylen < m) keylen = m;
+	if(keylen <= 0) return 0;
+	jbyte* keyptr = jenv->GetByteArrayElements(key, 0);
+	if(!keyptr) return 0;
+	std::string valstr;
+	Status s = db->Get(g_ro, Slice((const char*)keyptr, (size_t)keylen), &valstr);
+	jenv->ReleaseByteArrayElements(key, keyptr, JNI_ABORT);
+	if(!s.ok()) return 0;
+	jsize vallen = valstr.size();
+	jbyteArray val = jenv->NewByteArray(vallen);
+	jenv->SetByteArrayRegion(val, 0, vallen, (const jbyte*)valstr.data());
+	return val;
+}
+
+// public native static int leveldb_write(long handle, Iterator<Entry<Octets, OctetsStream>> buf);
+extern "C" JNIEXPORT jint JNICALL Java_jane_core_StorageLevelDB_leveldb_1write
+	(JNIEnv* jenv, jclass jcls, jlong handle, jobject it)
+{
+	DB* db = (DB*)handle;
+	if(!db || !it) return 1;
+	jclass cls_it = jenv->FindClass("java/util/Iterator");
+	if(!cls_it) return 2;
+	static jclass cls_entry = 0;
+	static jclass cls_octets = 0;
+	static jmethodID mid_hasNext = 0;
+	static jmethodID mid_next = 0;
+	static jmethodID mid_getKey = 0;
+	static jmethodID mid_getValue = 0;
+	static jfieldID fid_buffer = 0;
+	static jfieldID fid_count = 0;
+	static jint s_err = -1;
+	if(s_err < 0)
+	{
+		s_err = 0;
+		jclass cls_entry = jenv->FindClass("java/util/Map$Entry");
+		jclass cls_octets = jenv->FindClass("jane/core/Octets");
+		if(!cls_entry || !cls_octets) return s_err = 3;
+		mid_hasNext = jenv->GetMethodID(cls_it, "hasNext", "()Z");
+		mid_next = jenv->GetMethodID(cls_it, "next", "()Ljava/lang/Object;");
+		mid_getKey = jenv->GetMethodID(cls_entry, "getKey", "()Ljava/lang/Object;");
+		mid_getValue = jenv->GetMethodID(cls_entry, "getValue", "()Ljava/lang/Object;");
+		fid_buffer = jenv->GetFieldID(cls_octets, "buffer", "[B");
+		fid_count = jenv->GetFieldID(cls_octets, "count", "I");
+		if(!mid_hasNext || !mid_next || !mid_getKey || !mid_getValue || !fid_buffer || !fid_count) return s_err = 4;
+	}
+	else if(s_err > 0) return s_err;
+	if(jenv->IsInstanceOf(it, cls_it) == JNI_FALSE) return 5;
+	while(jenv->CallBooleanMethod(it, mid_hasNext) == JNI_TRUE)
+	{
+		jobject entry = jenv->CallObjectMethod(it, mid_next);
+		jobject key = jenv->CallObjectMethod(entry, mid_getKey);
+		if(key)
+		{
+			jbyteArray keybuf = (jbyteArray)jenv->GetObjectField(key, fid_buffer); // check cast and null?
+			jint keylen = jenv->GetIntField(key, fid_count);
+			if(keylen > 0)
+			{
+				jbyte* keyptr = jenv->GetByteArrayElements(keybuf, 0);
+				jobject val = jenv->CallObjectMethod(entry, mid_getValue);
+				if(val)
+				{
+					jbyteArray valbuf = (jbyteArray)jenv->GetObjectField(val, fid_buffer); // check cast and null?
+					jint vallen = jenv->GetIntField(val, fid_count);
+					if(vallen > 0)
+					{
+						jbyte* valptr = jenv->GetByteArrayElements(valbuf, 0);
+						g_wb.Put(Slice((const char*)keyptr, (size_t)keylen), Slice((const char*)valptr, (size_t)vallen));
+						jenv->ReleaseByteArrayElements(valbuf, valptr, JNI_ABORT);
+					}
+					else
+						g_wb.Delete(Slice((const char*)keyptr, (size_t)keylen));
+				}
+				else
+					g_wb.Delete(Slice((const char*)keyptr, (size_t)keylen));
+				jenv->ReleaseByteArrayElements(keybuf, keyptr, JNI_ABORT);
+			}
+		}
+	}
+	Status s = db->Write(g_wo, &g_wb);
+	g_wb.Clear();
+	return s.ok() ? 0 : 6;
+}
+
+#endif
